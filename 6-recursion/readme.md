可以实现一下斐波那契数列，输入一个数值 n，返回第 n 位的斐波那契数列或者返回长度为 n 的斐波那契数列。
### 参考文章
[programming with js recursion](https://hackernoon.com/programming-with-js-recursion-31371e2bf808)，这篇文章给递归下了个定义：
> Recursion is when a functions calls itself until it reaches a certain state
这个定义很好，里面界定了两个问题，第一递归有终止条件，第二递归就是在函数内部继续调用这个函数。

关于递归，SICP 中有两个图，一个是阶乘，一个是斐波那契数列，配图给出的文字说明分别是 linear-recursive progress 和 tree-recursive progress。显然递归也有分类，而且这两种递归形式应该也是最常见的形式。

> 计算机擅长做重复的事情，所以递归正和它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。
> 对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？
> 如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。
> 因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

人脑去理解递归会存在存储容量的极限，思考的应该更抽象一些。

### 到底什么是递归和分治
从最开始学习计算机就一直在尝试去理解什么是递归和分治，各种材料对我的启示其实已经很明显了。但是一直到今天我觉得我才真正的理解什么是递归和分治最核心的内容。这和我看'Discrete mathmatics' 有不可分割的原因。因为之前一直在初中高中给的时候学过一个定理：就是如果 1 在这个定理中成立，并且假设 n 成立，在这种情况下能推导出 n + 1
也成立的情况下，这个定理就是真定理。这个其实也给我对理解递归和分治有了很大的启发。虽然说递归一直说找到终止条件，写出递归公式就可以了。但是其实我一直默认对于终止条件的理解是很肤浅的。终止条件我今天才真正明白了，就是递归的初始值，第一个值，也就是所谓上面说的真理的起始条件，就是
1。所以分治思想也是一样的，分到什么情况就不分了，就是分到最开始的条件。递归的时候，递到什么时候不递了，就是递到初始值的时候。递归，分治都是把一个问题分解成更小量级的同样的问题。借用算法之美的文章原话：
> 将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

或者说分解到这个问题的最小单位，比如在 mergeSort 中，最小单位就是两个只有一个元素的数组的合并。
那个返回的条件是 arr.length < 2。


也就是说分解后的小问题和原问题的结构是一样的，那分解到哪一步就不分解了，那就是分解到最初的那个初始值开始。
很感谢数学，感谢初中高中的数学，虽然大学让我把那些内容已经忘得一干二净了，但是还是感谢数学，感谢离散数学，让我又想起了很多原来的记忆。而且数学才是真正的计算机的抽象。
