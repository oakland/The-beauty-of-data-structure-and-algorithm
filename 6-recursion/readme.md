可以实现一下斐波那契数列，输入一个数值 n，返回第 n 位的斐波那契数列或者返回长度为 n 的斐波那契数列。
### 参考文章
[programming with js recursion](https://hackernoon.com/programming-with-js-recursion-31371e2bf808)，这篇文章给递归下了个定义：
> Recursion is when a functions calls itself until it reaches a certain state
这个定义很好，里面界定了两个问题，第一递归有终止条件，第二递归就是在函数内部继续调用这个函数。

关于递归，SICP 中有两个图，一个是阶乘，一个是斐波那契数列，配图给出的文字说明分别是 linear-recursive progress 和 tree-recursive progress。显然递归也有分类，而且这两种递归形式应该也是最常见的形式。

> 计算机擅长做重复的事情，所以递归正和它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。
> 对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？
> 如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。
> 因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

人脑去理解递归会存在存储容量的极限，思考的应该更抽象一些。
