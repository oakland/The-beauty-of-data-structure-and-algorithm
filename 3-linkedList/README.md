### 没看懂的内容
Q: 技巧三：利用哨兵简化实现难度的这个部分中，作者写了两段代码对比。没看懂第二段代码哪里用到了哨兵？
A: 文章后面读者问答中，有一个“optvxq” 的读者解答了我的这个疑惑，就是利用哨兵减少了对 i 的越界判断。这个就是哨兵。
课程后面的问答中，有个“五岳寻仙”的读者问了个问题，老师说可以看下“内存池”这个概念。之前没有了解过，我也可以了解下这个概念的本质和意义。
### 心得体会
#### 如何解读 -> 和 =
在第七篇文章（链表（下）：如何轻松写出正确的代码）中，有很多伪代码，这些伪代码同时用了 -> 和 = 这样的符号。刚开始有点蒙蔽，因为不知道该从哪里断。比如
```
new_node->next = p->next;
p->next = new_node;
```
又看了一遍，觉得可以这样解读。`->` 表示‘的’，是一个从属关系，`=` 表示赋值这个动作，表示‘指向’这个动作。第一段话可以解读为‘new_node 的 next 指针 指向 p 的 next’。这样解读就会好很多。
#### 边界很重要
在‘代码一’中，要实现‘在数组 a 中，查找 key，返回 key 所在的位置’，这个方法的第一句话说的就是边界条件。一段良好的代码环境是有边界条件的。也就是说在创建函数或者方法的时候，就要想好边界是什么，并且在最开始就把边界条件写出来。通常链表边界条件包括：
- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
这个边界条件的处理其实也可以用在其他的数据结构中，比如数组。通常要注意的也就是一些特殊情况，比如没有传入，比如为空，比如只有一个或者两个，还有就是处理开始和结尾的时候要特殊处理。
> 实际上，不光光是写链表代码，你在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！

### 课后思考
本章课后要思考两个问题
1. 如何用数组实现 LRU 缓存策略
2. 如何用单链表实现字符串回文判断

链表（下）中的课后习题：
1. 单链表反转
2. 链表中环的检测
3. 两个有序链表的合并
4. 删除链表倒数第 n 个节点
5. 求链表的中间节点

可以通过看 js 数据结构和算法的书，来辅助学习这几个方法和操作。

### Grokking algorithm
这本书里的 chapter 2 里有关于数组和链表的内容，介绍的非常清晰。关于 linked list 和 array 的对比说的也很好。
> Linked lists are great if you're going to read all the items at a time: you can read one item, follow the address to the next item, and so on. But if you're going to keep jumping around, linked lists are terrible. Arrays are different. You know the address for every item in your array.
根据上面这段话，其实可以很明显的看出 linked list 和 array 之间的关系，以及他们各自适用的场景。

### 常见的链表
- 单链表
- 双向链表
- 循环链表

### 算法思想
...用空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，但时间复杂度相对很低的算法或者数据结构。...缓存实际上就是利用了空间换时间的设计思想。
cpu cache === processor cached，cpu 也会对数据进行缓存。这个应该是和操作系统相关的，可以看下这个机制和原理。
> 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。
上面这段话解释了为什么数组用的比较多的原因。
### LRU 缓存算法
这个算法用的是链表，为什么？是因为插入更加方便吗？因为在寻找是否在缓存中的时候，都是用遍历的方式，对于数组和链表而言，都是一样的时间复杂度？
这个实现的过程其实和看书很像。用一个例子来说明，更清楚。
假设有一个只能放 3
本书的盒子，盒子现在是空的，从今天开始每天看一本书。第一天看了数学，看完之后把数学放到盒子的第一位。第二天看了英语，看完之后，把数学向后移一位，然后把英语放在第一位。第三天看了语文，这个时候就把英语和数学都挪后一位，把语文放在第一位。这个时候盒子已经满了。第四天又想看数学，这个时候就把最后一位的数学拿出来，看完之后放到盒子的第一位，然后把语文和英语挪后一位。第五天如果想看物理了，这个时候盒子已经满了，就需要把盒子最后一位的英语扔掉，然后把物理放在第一位，然后把数学和语文都挪后一位。是不是这个过程很像是
LRU 呢？

### 课后思考题
用单链表判断回文，以及时间复杂度和空间复杂度分析，需要仔细看看。

### 自己的思考
感觉 linked list 其实是一种特殊的 tree，只有一个 child 的 tree 是不是就是 linked list？所以遍历整个 linked list 就像遍历 tree 一样，因为只有一个子节点，所以是深度遍历，而无法跳过任何一个节点，遍历下一个节点。那么其实插入和删除的操作也都是和 tree 一样的。

### 内存池
google 查了下 memory pool，给出了 [stackoverflow](https://stackoverflow.com/questions/30508183/how-does-memory-pools-work)的一个回答，排名第一的回答说的很好。就是任何 pool 都是提前获取的资源。之前还听说过线程池，就是 thread pool 的概念。都表示提前获取，而不是在使用的时候临时去申请。这样的好处在于减少了申请和销毁的操作，避免了申请和销毁对程序的影响，而加快了程序的执行速度，但是这种提前申请不可避免的会造成一些浪费。所以申请的时候要申请合适数量的资源。
http://www.codinglabs.net/tutorial_memory_pool.aspx，这篇文章好像很专业。
