### 心得体会
#### 如何解读 -> 和 =
在第七篇文章（链表（下）：如何轻松写出正确的代码）中，有很多伪代码，这些伪代码同时用了 -> 和 = 这样的符号。刚开始有点蒙蔽，因为不知道该从哪里断。比如
```
new_node->next = p->next;
p->next = new_node;
```
又看了一遍，觉得可以这样解读。`->` 表示‘的’，是一个从属关系，`=` 表示赋值这个动作，表示‘指向’这个动作。第一段话可以解读为‘new_node 的 next 指针 指向 p 的 next’。这样解读就会好很多。
#### 边界很重要
在‘代码一’中，要实现‘在数组 a 中，查找 key，返回 key 所在的位置’，这个方法的第一句话说的就是边界条件。一段良好的代码环境是有边界条件的。也就是说在创建函数或者方法的时候，就要想好边界是什么，并且在最开始就把边界条件写出来。通常链表边界条件包括：
- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
这个边界条件的处理其实也可以用在其他的数据结构中，比如数组。通常要注意的也就是一些特殊情况，比如没有传入，比如为空，比如只有一个或者两个，还有就是处理开始和结尾的时候要特殊处理。
> 实际上，不光光是写链表代码，你在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！

### 课后思考
本章课后要思考两个问题
1. 如何用数组实现 LRU 缓存策略
2. 如何用单链表实现字符串回文判断

链表（下）中的课后习题：
1. 单链表反转
2. 链表中环的检测
3. 两个有序链表的合并
4. 删除链表倒数第 n 个节点
5. 求链表的中间节点

可以通过看 js 数据结构和算法的书，来辅助学习这几个方法和操作。

### Grokking algorithm
这本书里的 chapter 2 里有关于数组和链表的内容，介绍的非常清晰。关于 linked list 和 array 的对比说的也很好。
> Linked lists are great if you're going to read all the items at a time: you can read one item, follow the address to the next item, and so on. But if you're going to keep jumping around, linked lists are terrible. Arrays are different. You know the address for every item in your array.
根据上面这段话，其实可以很明显的看出 linked list 和 array 之间的关系，以及他们各自适用的场景。

### 常见的链表
- 单链表
- 双向链表
- 循环链表

### 算法思想
...用空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，但时间复杂度相对很低的算法或者数据结构。...缓存实际上就是利用了空间换时间的设计思想。
cpu cache === processor cached，cpu 也会对数据进行缓存。这个应该是和操作系统相关的，可以看下这个机制和原理。
> 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。
上面这段话解释了为什么数组用的比较多的原因。
### LRU 缓存算法
这个算法用的是链表，为什么？是因为插入更加方便吗？因为在寻找是否在缓存中的时候，都是用遍历的方式，对于数组和链表而言，都是一样的时间复杂度？
### 课后思考题
用单链表判断回文，以及时间复杂度和空间复杂度分析，需要仔细看看。
